<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sainsbury's Bill Splitter</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        #root { max-width: 800px; margin: 0 auto; }
        .card { background: white; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); padding: 32px; margin-bottom: 24px; position: relative; }
        .title { font-size: 32px; font-weight: bold; color: #1f2937; margin-bottom: 8px; }
        .subtitle { color: #6b7280; margin-bottom: 24px; }
        .upload-area { border: 3px dashed #d1d5db; border-radius: 12px; padding: 48px; text-align: center; cursor: pointer; transition: all 0.3s; background: #f9fafb; }
        .upload-area:hover, .upload-area.drag-over { border-color: #667eea; background: #eef2ff; }
        .upload-icon { font-size: 48px; margin-bottom: 16px; }
        .upload-text { font-size: 18px; color: #4b5563; margin-bottom: 8px; }
        .upload-hint { font-size: 14px; color: #9ca3af; }
        .progress-bar { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; overflow: hidden; margin-bottom: 16px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #f97316, #fb923c); transition: width 0.3s; }
        .progress-text { text-align: right; color: #6b7280; font-size: 14px; margin-bottom: 24px; padding-right: 60px; }
        .item-card { background: #fffbeb; border-radius: 12px; padding: 24px; margin-bottom: 24px; border-left: 4px solid #f59e0b; }
        .item-name { font-size: 20px; font-weight: 600; color: #1f2937; margin-bottom: 8px; line-height: 1.4; }
        .item-details { display: flex; gap: 24px; color: #6b7280; font-size: 14px; margin-bottom: 20px; }
        .button { padding: 16px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .button-primary { background: #667eea; color: white; }
        .button-primary:hover { background: #5568d3; transform: translateY(-2px); }
        .button-secondary { background: #10b981; color: white; }
        .button-secondary:hover { background: #059669; transform: translateY(-2px); }
        .button-tertiary { background: #f59e0b; color: white; }
        .button-tertiary:hover { background: #d97706; transform: translateY(-2px); }
        .button-custom { background: #8b5cf6; color: white; }
        .button-custom:hover { background: #7c3aed; transform: translateY(-2px); }
        .button-back { background: #6b7280; color: white; }
        .button-back:hover { background: #4b5563; }
        .button-group { display: flex; gap: 16px; }
        .button-group button { flex: 1; }
        .custom-split-panel { background: #f3f4f6; border-radius: 12px; padding: 24px; margin-top: 16px; }
        .custom-split-title { font-size: 18px; font-weight: 600; color: #1f2937; margin-bottom: 16px; text-align: center; }
        .split-person-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding: 12px; background: white; border-radius: 8px; }
        .split-person-name { font-weight: 600; color: #1f2937; width: 80px; }
        .split-controls { display: flex; align-items: center; gap: 12px; flex: 1; }
        .split-button { background: #667eea; color: white; border: none; border-radius: 6px; width: 36px; height: 36px; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .split-button:hover { background: #5568d3; }
        .split-button:disabled { background: #d1d5db; cursor: not-allowed; }
        .split-input { width: 80px; text-align: center; border: 2px solid #d1d5db; border-radius: 6px; padding: 8px; font-size: 16px; font-weight: 600; }
        .split-amount { font-size: 16px; font-weight: 600; color: #059669; width: 80px; text-align: right; }
        .split-actions { display: flex; gap: 12px; margin-top: 16px; }
        .split-actions button { flex: 1; }
        .quantity-split-panel { background: #fef3c7; border-radius: 12px; padding: 20px; margin-top: 16px; }
        .quantity-split-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .quantity-split-label { font-weight: 600; color: #78350f; }
        .quantity-input { width: 60px; text-align: center; border: 2px solid #fbbf24; border-radius: 6px; padding: 6px; font-size: 16px; font-weight: 600; }
        .quantity-total { font-size: 14px; color: #92400e; margin-top: 8px; text-align: center; }
        .split-type-toggle { display: flex; gap: 8px; margin-bottom: 16px; }
        .split-type-button { flex: 1; padding: 12px; border: 2px solid #d1d5db; background: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
        .split-type-button.active { border-color: #667eea; background: #eef2ff; color: #667eea; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px; }
        .person-card { background: linear-gradient(135deg, #fef3c7 0%, #fcd34d 100%); border-radius: 12px; padding: 20px; text-align: center; }
        .person-name { font-size: 18px; font-weight: bold; color: #78350f; margin-bottom: 8px; }
        .person-amount { font-size: 28px; font-weight: bold; color: #92400e; }
        .person-breakdown { font-size: 12px; color: #92400e; margin-top: 8px; opacity: 0.8; }
        .total-bill { background: linear-gradient(135deg, #fed7aa 0%, #fb923c 100%); border-radius: 12px; padding: 24px; text-align: center; margin-bottom: 24px; }
        .total-bill-label { font-size: 14px; opacity: 0.8; margin-bottom: 4px; }
        .total-bill-amount { font-size: 36px; font-weight: bold; }
        .divider { border: none; border-top: 1px solid #fed7aa; margin: 16px 0; }
        .details-section { margin-bottom: 24px; }
        details { background: #f9fafb; border-radius: 8px; margin-bottom: 12px; }
        summary { padding: 16px; font-weight: 600; cursor: pointer; color: #1f2937; }
        summary:hover { background: #f3f4f6; }
        .item-list { padding: 0 16px 16px 16px; }
        .item-row { display: flex; justify-content: space-between; font-size: 14px; padding: 8px 0; border-bottom: 1px solid #e5e7eb; }
        .item-row:last-child { border-bottom: none; }
        .item-row-name { color: #4b5563; flex: 1; }
        .item-row-price { font-weight: 600; color: #1f2937; margin-left: 16px; }
        .loading { text-align: center; padding: 32px; color: #666; }
        .error { background: #fef2f2; color: #991b1b; padding: 16px; border-radius: 8px; margin-bottom: 16px; }
        .assignment-indicator { background: #e0e7ff; border: 2px solid #818cf8; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .assignment-title { font-size: 14px; font-weight: 600; color: #4338ca; margin-bottom: 8px; }
        .assignment-detail { font-size: 13px; color: #4338ca; line-height: 1.6; }
        .assignment-detail-row { display: flex; justify-content: space-between; padding: 4px 0; }
        .settings-button { position: fixed; top: 32px; right: calc(50% - 400px - 70px); background: #6b7280; color: white; border: none; border-radius: 50%; width: 56px; height: 56px; font-size: 24px; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; }
        .settings-button:hover { background: #4b5563; transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0,0,0,0.2); }
        .settings-button.active-split { background: #f59e0b; }
        .settings-button.active-split:hover { background: #d97706; }
        .active-split-notice { background: #fef3c7; border: 2px solid #f59e0b; border-radius: 12px; padding: 16px; margin-bottom: 24px; display: flex; align-items: center; gap: 12px; }
        .active-split-notice-icon { font-size: 24px; }
        .active-split-notice-text { flex: 1; color: #92400e; font-weight: 500; }
        .settings-container { max-width: 700px; }
        .settings-section { margin-bottom: 24px; background: #f9fafb; padding: 24px; border-radius: 12px; }
        .settings-section-title { font-size: 20px; font-weight: 600; color: #1f2937; margin-bottom: 16px; border-bottom: 2px solid #d1d5db; padding-bottom: 8px; }
        .settings-table { width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .settings-table thead { background: #f3f4f6; }
        .settings-table th { padding: 12px 16px; text-align: left; font-weight: 600; color: #1f2937; border-bottom: 2px solid #d1d5db; font-size: 14px; }
        .settings-table td { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; }
        .settings-table tbody tr:last-child td { border-bottom: none; }
        .settings-table tbody tr:hover { background: #f9fafb; }
        .group-select { width: 100%; padding: 8px 12px; border: 2px solid #d1d5db; border-radius: 6px; font-size: 14px; cursor: pointer; background: white; transition: border-color 0.2s; }
        .group-select:focus { outline: none; border-color: #667eea; }
        .group-select:hover { border-color: #9ca3af; }
        .item-actions { display: flex; gap: 8px; justify-content: flex-end; }
        .icon-button { background: none; border: none; color: #6b7280; cursor: pointer; font-size: 18px; padding: 8px; transition: all 0.2s; border-radius: 4px; }
        .icon-button:hover { background: #f3f4f6; color: #1f2937; }
        .icon-button.delete:hover { background: #fee2e2; color: #991b1b; }
        .add-button { background: #10b981; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; width: 100%; margin-top: 12px; transition: all 0.2s; font-size: 14px; }
        .add-button:hover { background: #059669; transform: translateY(-1px); }
        .group-list { display: flex; flex-direction: column; gap: 8px; }
        .group-item { background: white; padding: 14px 16px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .group-name-display { font-weight: 600; color: #1f2937; flex: 1; }
        .group-member-count { font-size: 13px; color: #6b7280; margin-left: 12px; }
        .inline-edit-input { border: 2px solid #667eea; border-radius: 6px; padding: 6px 10px; font-size: 14px; font-weight: 600; width: 200px; }
        .inline-edit-input:focus { outline: none; border-color: #5568d3; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal-content { background: white; border-radius: 16px; padding: 32px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; }
        .group-edit-table { width: 100%; border-collapse: collapse; margin-top: 16px; }
        .group-edit-table th { background: #f3f4f6; padding: 12px; text-align: left; font-weight: 600; color: #1f2937; border: 1px solid #d1d5db; }
        .group-edit-table td { padding: 10px 12px; border: 1px solid #e5e7eb; }
        .group-edit-table tbody tr:nth-child(even) { background: #f9fafb; }
        .group-edit-table tbody tr:hover { background: #f3f4f6; }
        .group-edit-select { width: 100%; padding: 8px; border: 2px solid #d1d5db; border-radius: 6px; font-size: 14px; cursor: pointer; transition: border-color 0.2s; }
        .group-edit-select:focus { outline: none; border-color: #667eea; }
        .modal-title { font-size: 24px; font-weight: bold; color: #1f2937; margin-bottom: 24px; }
        .form-group { margin-bottom: 20px; }
        .form-label { display: block; font-weight: 600; color: #1f2937; margin-bottom: 8px; }
        .form-input { width: 100%; padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 16px; transition: border-color 0.2s; }
        .form-input:focus { outline: none; border-color: #667eea; }
        .error-message { background: #fee2e2; color: #991b1b; padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 14px; }
        .warning-box { background: #fef3c7; padding: 16px; border-radius: 8px; margin-bottom: 20px; }
        .warning-title { color: #78350f; margin-bottom: 8px; font-weight: 600; }
        .warning-text { color: #92400e; font-size: 14px; }
        .checkbox-group { display: flex; flex-direction: column; gap: 8px; }
        .checkbox-label { display: flex; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; transition: background 0.2s; }
        .checkbox-label:hover { background: #f3f4f6; }
        .checkbox-label input { margin-right: 12px; width: 18px; height: 18px; cursor: pointer; }
        .radio-group { display: flex; flex-direction: column; gap: 8px; }
        .radio-label { display: flex; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; transition: background 0.2s; }
        .radio-label:hover { background: #f3f4f6; }
        .radio-label input { margin-right: 12px; width: 18px; height: 18px; cursor: pointer; }
        .radio-label.current-group { background: #e0e7ff; font-weight: 600; }
        .group-info { font-size: 12px; color: #6b7280; margin-left: 30px; margin-top: 4px; }
        .review-table { width: 100%; border-collapse: collapse; margin-bottom: 24px; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .review-table thead { background: #f3f4f6; }
        .review-table th { padding: 12px 16px; text-align: left; font-weight: 600; color: #1f2937; border-bottom: 2px solid #d1d5db; font-size: 14px; }
        .review-table td { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; }
        .review-table tbody tr:last-child td { border-bottom: none; }
        .review-table tbody tr:hover { background: #f9fafb; }
        .prediction-badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: 600; }
        .prediction-badge.high { background: #d1fae5; color: #065f46; }
        .prediction-badge.medium { background: #fef3c7; color: #78350f; }
        .prediction-badge.none { background: #f3f4f6; color: #6b7280; }
        .change-button { background: #667eea; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .change-button:hover { background: #5568d3; }
        .review-summary { background: #f3f4f6; border-radius: 12px; padding: 20px; margin-bottom: 24px; text-align: center; }
        .review-summary-stat { font-size: 18px; font-weight: 600; color: #1f2937; margin-bottom: 8px; }
        .review-summary-text { font-size: 14px; color: #6b7280; }
        .suggestion-hint { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px 16px; margin-bottom: 16px; border-radius: 4px; }
        .suggestion-hint-text { font-size: 14px; color: #78350f; }
        .suggestion-hint-subtext { font-size: 12px; color: #92400e; margin-top: 4px; }
        .settings-toggle { display: flex; align-items: center; justify-content: space-between; padding: 12px; background: white; border-radius: 8px; margin-bottom: 8px; }
        .settings-toggle-label { font-weight: 600; color: #1f2937; }
        .settings-toggle-description { font-size: 13px; color: #6b7280; margin-top: 4px; }
        .toggle-switch { position: relative; display: inline-block; width: 48px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #d1d5db; transition: .3s; border-radius: 24px; }
        .toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; }
        .toggle-switch input:checked + .toggle-slider { background-color: #10b981; }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(24px); }
        .clear-history-button { background: #ef4444; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; width: 100%; margin-top: 12px; transition: all 0.2s; font-size: 14px; }
        .clear-history-button:hover { background: #dc2626; transform: translateY(-1px); }
        .unassigned-notice { background: #f9fafb; padding: 16px; border-radius: 8px; margin-top: 16px; border: 1px solid #d1d5db; }
        .unassigned-title { font-weight: 600; color: #4b5563; margin-bottom: 8px; }
        .unassigned-list { color: #6b7280; font-size: 14px; }
        .modal-actions { display: flex; gap: 12px; margin-top: 24px; }
        .modal-actions button { flex: 1; }
        @media (max-width: 640px) {
            .card { padding: 20px; }
            .title { font-size: 24px; }
            .item-name { font-size: 18px; }
            .button-group { flex-direction: column; }
            .split-person-row { flex-wrap: wrap; }
            .split-controls { width: 100%; margin-top: 8px; }
            .settings-button { top: 20px; right: 20px; width: 48px; height: 48px; font-size: 20px; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Default configuration
        const DEFAULT_CONFIG = {
            people: ['Richard', 'Lisa', 'Rosie', 'Molly', 'Joe', 'Stu'],
            groups: [
                { name: 'Adults', members: ['Richard', 'Lisa'] },
                { name: 'Kids', members: ['Rosie', 'Molly', 'Joe', 'Stu'] }
            ]
        };

        // Load configuration from localStorage or use defaults
        const loadConfig = () => {
            try {
                const saved = localStorage.getItem('billSplitterConfig');
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.error('Error loading config:', e);
            }
            return DEFAULT_CONFIG;
        };

        // Save configuration to localStorage
        const saveConfig = (config) => {
            try {
                localStorage.setItem('billSplitterConfig', JSON.stringify(config));
            } catch (e) {
                console.error('Error saving config:', e);
            }
        };

        // Prediction history management
        const loadPredictionHistory = () => {
            try {
                const saved = localStorage.getItem('billSplitterHistory');
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.error('Error loading prediction history:', e);
            }
            return {};
        };

        const savePredictionHistory = (history) => {
            try {
                localStorage.setItem('billSplitterHistory', JSON.stringify(history));
            } catch (e) {
                console.error('Error saving prediction history:', e);
            }
        };

        const clearPredictionHistory = () => {
            try {
                localStorage.removeItem('billSplitterHistory');
            } catch (e) {
                console.error('Error clearing prediction history:', e);
            }
        };

        // Load prediction settings
        const loadPredictionSettings = () => {
            try {
                const saved = localStorage.getItem('billSplitterPredictionSettings');
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.error('Error loading prediction settings:', e);
            }
            return {
                enablePredictions: true,
                showReviewScreen: true,
                autoApplyHighConfidence: false
            };
        };

        const savePredictionSettings = (settings) => {
            try {
                localStorage.setItem('billSplitterPredictionSettings', JSON.stringify(settings));
            } catch (e) {
                console.error('Error saving prediction settings:', e);
            }
        };

        const BillSplitter = () => {
            const [items, setItems] = useState([]);
            const [currentItemIndex, setCurrentItemIndex] = useState(0);
            const [assignments, setAssignments] = useState({});
            const [showSummary, setShowSummary] = useState(false);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [dragOver, setDragOver] = useState(false);
            const [showCustomSplit, setShowCustomSplit] = useState(false);
            const [splitType, setSplitType] = useState('percentage'); // 'percentage' or 'quantity'
            const [showSettings, setShowSettings] = useState(false);
            const [config, setConfig] = useState(loadConfig());
            const [initialConfig, setInitialConfig] = useState(null); // Config snapshot when bill split started
            const [showResetWarning, setShowResetWarning] = useState(false);
            const [pendingConfig, setPendingConfig] = useState(null);
            const [configChanges, setConfigChanges] = useState([]);

            // Prediction system state
            const [predictionHistory, setPredictionHistory] = useState(loadPredictionHistory());
            const [predictionSettings, setPredictionSettings] = useState(loadPredictionSettings());
            const [predictions, setPredictions] = useState({});
            const [showReviewScreen, setShowReviewScreen] = useState(false);
            const [reviewAssignments, setReviewAssignments] = useState({});

            // Custom split percentages (dynamic based on config)
            const [customSplit, setCustomSplit] = useState({});

            // Track which percentages have been manually adjusted
            const [manuallyAdjusted, setManuallyAdjusted] = useState(new Set());

            // Quantity-based split
            const [quantitySplit, setQuantitySplit] = useState({});

            // Initialize custom split based on config
            useEffect(() => {
                const initialSplit = {};
                const numPeople = config.people.length;
                const basePercent = Math.floor((100 / numPeople) * 100) / 100;
                const remainder = 100 - (basePercent * numPeople);

                config.people.forEach((person, idx) => {
                    initialSplit[person] = idx === numPeople - 1 ? basePercent + remainder : basePercent;
                });

                setCustomSplit(initialSplit);
            }, [config.people]);

            // Keyboard shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Don't trigger if user is typing in an input field, textarea, or if a modal is open
                    const isTyping = ['INPUT', 'TEXTAREA'].includes(e.target.tagName);

                    // Only active when on item assignment screen (items exist, not in summary, not in settings)
                    const isItemAssignmentScreen = items.length > 0 && !showSummary && !showSettings;

                    if (!isItemAssignmentScreen) return;

                    // Handle Escape key - close custom split modal or go back
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (showCustomSplit) {
                            setShowCustomSplit(false);
                        } else if (currentItemIndex > 0) {
                            goBack();
                        }
                        return;
                    }

                    // Handle Left Arrow - go back
                    if (e.key === 'ArrowLeft' && !isTyping) {
                        e.preventDefault();
                        if (currentItemIndex > 0 || showCustomSplit) {
                            goBack();
                        }
                        return;
                    }

                    // Don't trigger number shortcuts if typing in input field or custom split is open
                    if (isTyping || showCustomSplit) return;

                    // Handle number keys 1-9 for button assignment
                    if (e.key >= '1' && e.key <= '9') {
                        const buttonIndex = parseInt(e.key) - 1;

                        // Build the button list: groups first, then "Shared", then "Custom Split"
                        const buttonActions = [
                            ...config.groups.map(group => () => assignItem(group.name)),
                            () => assignItem('Shared'),
                            () => openCustomSplit()
                        ];

                        if (buttonIndex < buttonActions.length) {
                            e.preventDefault();
                            buttonActions[buttonIndex]();
                        }
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [items, showSummary, showSettings, showCustomSplit, currentItemIndex, config.groups, assignItem, openCustomSplit, goBack]);

            // Generate predictions for all items
            const generatePredictions = (itemsList) => {
                if (!predictionSettings.enablePredictions) {
                    return {};
                }

                const predictions = {};
                itemsList.forEach((item, index) => {
                    const itemKey = item.name.toLowerCase().trim();
                    const historyEntry = predictionHistory[itemKey];

                    if (historyEntry && historyEntry.assignments) {
                        // Find the most frequently used assignment
                        const sortedAssignments = Object.entries(historyEntry.assignments)
                            .sort((a, b) => b[1] - a[1]);

                        if (sortedAssignments.length > 0) {
                            const [mostFrequentGroup, count] = sortedAssignments[0];
                            const totalCount = Object.values(historyEntry.assignments).reduce((sum, c) => sum + c, 0);

                            // Determine confidence level
                            let confidence = 'none';
                            if (count >= 3 && count === totalCount) {
                                confidence = 'high';
                            } else if (count >= 1) {
                                confidence = 'medium';
                            }

                            predictions[index] = {
                                group: mostFrequentGroup,
                                confidence: confidence,
                                count: count,
                                totalCount: totalCount
                            };
                        }
                    }
                });

                return predictions;
            };

            // Learn from assignments after completion
            const learnFromAssignments = (finalAssignments) => {
                const newHistory = { ...predictionHistory };
                const now = new Date().toISOString().split('T')[0];

                items.forEach((item, index) => {
                    const assignment = finalAssignments[index];
                    if (!assignment) return;

                    const itemKey = item.name.toLowerCase().trim();
                    let assignedGroup = '';

                    // Extract the group name from assignment
                    if (typeof assignment === 'string') {
                        assignedGroup = assignment;
                    } else if (assignment.type === 'custom' || assignment.type === 'quantity') {
                        // For custom splits, we'll store the dominant group
                        const splits = assignment.type === 'custom' ? assignment.splits : assignment.splits;
                        const sortedSplits = Object.entries(splits).sort((a, b) => b[1] - a[1]);
                        if (sortedSplits.length > 0) {
                            assignedGroup = sortedSplits[0][0];
                        }
                    }

                    if (assignedGroup) {
                        if (!newHistory[itemKey]) {
                            newHistory[itemKey] = {
                                group: assignedGroup,
                                assignments: {},
                                lastUsed: now
                            };
                        }

                        if (!newHistory[itemKey].assignments) {
                            newHistory[itemKey].assignments = {};
                        }

                        newHistory[itemKey].assignments[assignedGroup] =
                            (newHistory[itemKey].assignments[assignedGroup] || 0) + 1;
                        newHistory[itemKey].group = assignedGroup;
                        newHistory[itemKey].lastUsed = now;
                    }
                });

                setPredictionHistory(newHistory);
                savePredictionHistory(newHistory);
            };

            const extractTextFromPdf = async (file) => {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                let allText = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();

                    const sortedItems = textContent.items.sort((a, b) => {
                        const yDiff = Math.abs(b.transform[5] - a.transform[5]);
                        if (yDiff > 2) return b.transform[5] - a.transform[5];
                        return a.transform[4] - b.transform[4];
                    });

                    let lastY = null;
                    for (let item of sortedItems) {
                        const y = Math.round(item.transform[5]);
                        if (lastY !== null && Math.abs(y - lastY) > 2) {
                            allText += '\n';
                        }
                        allText += item.str;
                        lastY = y;
                    }
                    allText += '\n';
                }

                return allText.split('\n');
            };

            const parsePdfLines = (lines) => {
                const items = [];
                let inGroceries = false;
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i].trim();

                    if (line.includes('Groceries (') && line.includes('items)')) {
                        inGroceries = true;
                        i++;
                        continue;
                    }

                    if (line.includes('Order summary')) {
                        break;
                    }

                    if (!inGroceries) {
                        i++;
                        continue;
                    }

                    if (!line) {
                        i++;
                        continue;
                    }

                    const singleLineMatch = line.match(/^(\d+(?:\.\d+)?(?:kg)?)\s+(.+?)\s+£([\d.]+)$/);

                    if (singleLineMatch) {
                        const quantity = singleLineMatch[1];
                        const name = singleLineMatch[2].trim();
                        const price = parseFloat(singleLineMatch[3]);

                        if (name && price > 0) {
                            items.push({ quantity, name, price });
                        }
                        i++;
                    } else {
                        const startMatch = line.match(/^(\d+(?:\.\d+)?(?:kg)?)\s+(.+)$/);

                        if (startMatch && i + 1 < lines.length) {
                            const nextLine = lines[i + 1].trim();
                            const priceMatch = nextLine.match(/^(.+?)\s+£([\d.]+)$/);

                            if (priceMatch) {
                                const quantity = startMatch[1];
                                const namePart1 = startMatch[2].trim();
                                const namePart2 = priceMatch[1].trim();
                                const name = (namePart1 + ' ' + namePart2).trim();
                                const price = parseFloat(priceMatch[2]);

                                if (name && price > 0) {
                                    items.push({ quantity, name, price });
                                }
                                i += 2;
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                }

                return items;
            };

            const handleFileUpload = async (file) => {
                if (!file || file.type !== 'application/pdf') {
                    setError('Please upload a PDF file');
                    return;
                }

                setLoading(true);
                setError('');

                try {
                    const lines = await extractTextFromPdf(file);
                    const extractedItems = parsePdfLines(lines);

                    if (extractedItems.length === 0) {
                        setError('Could not extract items from PDF. Please make sure this is a Sainsbury\'s receipt.');
                        setLoading(false);
                        return;
                    }

                    setItems(extractedItems);
                    setCurrentItemIndex(0);
                    setAssignments({});
                    setShowSummary(false);
                    setLoading(false);
                    // Snapshot the current config as the initial config for this bill split
                    setInitialConfig(JSON.parse(JSON.stringify(config)));

                    // Generate predictions
                    const itemPredictions = generatePredictions(extractedItems);
                    setPredictions(itemPredictions);

                    // If review screen is enabled and we have predictions, show it
                    if (predictionSettings.enablePredictions && predictionSettings.showReviewScreen) {
                        // Initialize review assignments with predictions
                        const initialReviewAssignments = {};
                        Object.entries(itemPredictions).forEach(([index, prediction]) => {
                            if (predictionSettings.autoApplyHighConfidence && prediction.confidence === 'high') {
                                initialReviewAssignments[index] = prediction.group;
                            } else if (prediction.confidence !== 'none') {
                                initialReviewAssignments[index] = prediction.group;
                            }
                        });
                        setReviewAssignments(initialReviewAssignments);
                        setShowReviewScreen(true);
                    }
                } catch (err) {
                    setError('Error reading PDF: ' + err.message);
                    setLoading(false);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setDragOver(false);
                const file = e.dataTransfer.files[0];
                handleFileUpload(file);
            };

            const handleFileSelect = (e) => {
                const file = e.target.files[0];
                handleFileUpload(file);
            };

            const assignItem = (group) => {
                const newAssignments = { ...assignments };
                newAssignments[currentItemIndex] = group;
                setAssignments(newAssignments);
                setShowCustomSplit(false);

                if (currentItemIndex < items.length - 1) {
                    setCurrentItemIndex(currentItemIndex + 1);
                } else {
                    setShowSummary(true);
                    // Learn from assignments when reaching summary
                    setTimeout(() => learnFromAssignments(newAssignments), 100);
                }
            };

            const openCustomSplit = () => {
                // Reset to equal split (all people)
                const initialSplit = {};
                const numPeople = config.people.length;
                const basePercent = Math.floor((100 / numPeople) * 100) / 100;
                const remainder = 100 - (basePercent * numPeople);

                config.people.forEach((person, idx) => {
                    initialSplit[person] = idx === numPeople - 1 ? basePercent + remainder : basePercent;
                });

                setCustomSplit(initialSplit);

                // Reset manually adjusted tracking
                setManuallyAdjusted(new Set());

                // Reset quantity split to equal distribution among groups
                const currentItem = items[currentItemIndex];
                const qty = parseFloat(currentItem.quantity) || 1;
                const quantityGroupSplit = {};

                if (config.groups.length > 0) {
                    const qtyPerGroup = Math.floor(qty / config.groups.length);
                    const remainder = qty - (qtyPerGroup * config.groups.length);
                    config.groups.forEach((group, idx) => {
                        quantityGroupSplit[group.name] = idx === 0 ? qtyPerGroup + remainder : qtyPerGroup;
                    });
                }

                setQuantitySplit(quantityGroupSplit);
                setSplitType('percentage');
                setShowCustomSplit(true);
            };

            const redistributePercentages = (changedPerson, newValue) => {
                const people = config.people;
                const newSplit = { ...customSplit };
                newSplit[changedPerson] = newValue;

                // Mark this person as manually adjusted
                const newManuallyAdjusted = new Set(manuallyAdjusted);
                newManuallyAdjusted.add(changedPerson);

                // Get list of people who haven't been manually adjusted (excluding the changed person)
                const autoAdjustPeople = people.filter(p =>
                    p !== changedPerson && !newManuallyAdjusted.has(p)
                );

                // Calculate remaining percentage to distribute
                const manualTotal = people
                    .filter(p => newManuallyAdjusted.has(p))
                    .reduce((sum, p) => sum + (newSplit[p] || 0), 0);

                const remainingPercentage = 100 - manualTotal;

                // Distribute remaining percentage equally among auto-adjust people
                if (autoAdjustPeople.length > 0) {
                    const perPerson = remainingPercentage / autoAdjustPeople.length;
                    autoAdjustPeople.forEach((p, idx) => {
                        // Round to 2 decimal places, adjust last person to make exact 100%
                        if (idx === autoAdjustPeople.length - 1) {
                            const totalSoFar = people
                                .filter(person => person !== p)
                                .reduce((sum, person) => sum + (newSplit[person] || 0), 0);
                            newSplit[p] = Math.round((100 - totalSoFar) * 100) / 100;
                        } else {
                            newSplit[p] = Math.round(perPerson * 100) / 100;
                        }
                    });
                }

                setCustomSplit(newSplit);
                setManuallyAdjusted(newManuallyAdjusted);
            };

            const updatePercentage = (person, delta) => {
                let newValue = customSplit[person] + delta;
                newValue = Math.max(0, Math.min(100, newValue));
                newValue = Math.round(newValue * 100) / 100;
                redistributePercentages(person, newValue);
            };

            const setPercentage = (person, value) => {
                let newValue = parseFloat(value) || 0;
                newValue = Math.max(0, Math.min(100, newValue));
                redistributePercentages(person, newValue);
            };

            const resetToEqualSplit = () => {
                // Reset to equal split among all people
                const initialSplit = {};
                const numPeople = config.people.length;
                const basePercent = Math.floor((100 / numPeople) * 100) / 100;
                const remainder = 100 - (basePercent * numPeople);

                config.people.forEach((person, idx) => {
                    initialSplit[person] = idx === numPeople - 1 ? basePercent + remainder : basePercent;
                });

                setCustomSplit(initialSplit);
                // Clear manually adjusted tracking
                setManuallyAdjusted(new Set());
            };

            const updateQuantity = (group, value) => {
                const newSplit = { ...quantitySplit };
                const qty = parseInt(value) || 0;
                newSplit[group] = Math.max(0, qty);
                setQuantitySplit(newSplit);
            };

            const applyCustomSplit = () => {
                const currentItem = items[currentItemIndex];
                const newAssignments = { ...assignments };

                if (splitType === 'percentage') {
                    newAssignments[currentItemIndex] = {
                        type: 'custom',
                        splits: { ...customSplit },
                        price: currentItem.price
                    };
                } else {
                    // Quantity-based split
                    newAssignments[currentItemIndex] = {
                        type: 'quantity',
                        splits: { ...quantitySplit },
                        price: currentItem.price,
                        totalQty: parseFloat(currentItem.quantity) || 1
                    };
                }

                setAssignments(newAssignments);
                setShowCustomSplit(false);

                if (currentItemIndex < items.length - 1) {
                    setCurrentItemIndex(currentItemIndex + 1);
                } else {
                    setShowSummary(true);
                    // Learn from assignments when reaching summary
                    setTimeout(() => learnFromAssignments(newAssignments), 100);
                }
            };

            const goBack = () => {
                if (showCustomSplit) {
                    setShowCustomSplit(false);
                } else if (currentItemIndex > 0) {
                    setCurrentItemIndex(currentItemIndex - 1);
                    setShowCustomSplit(false);
                }
            };

            const calculateSummary = () => {
                const totals = {};
                config.people.forEach(person => {
                    totals[person] = 0;
                });

                items.forEach((item, index) => {
                    const assignment = assignments[index];

                    if (!assignment) return;

                    if (typeof assignment === 'string') {
                        // Group assignment
                        if (assignment === 'Shared') {
                            // Split equally among all people
                            const perPerson = item.price / config.people.length;
                            config.people.forEach(person => {
                                totals[person] += perPerson;
                            });
                        } else {
                            // Find the group and split among its members
                            const group = config.groups.find(g => g.name === assignment);
                            if (group && group.members.length > 0) {
                                const perPerson = item.price / group.members.length;
                                group.members.forEach(person => {
                                    if (totals[person] !== undefined) {
                                        totals[person] += perPerson;
                                    }
                                });
                            }
                        }
                    } else if (assignment.type === 'custom') {
                        // Percentage-based custom split
                        config.people.forEach(person => {
                            if (assignment.splits[person]) {
                                totals[person] += (item.price * assignment.splits[person]) / 100;
                            }
                        });
                    } else if (assignment.type === 'quantity') {
                        // Quantity-based split
                        const pricePerUnit = item.price / assignment.totalQty;
                        Object.entries(assignment.splits).forEach(([groupName, qty]) => {
                            const group = config.groups.find(g => g.name === groupName) ||
                                         { name: 'Shared', members: config.people };
                            if (group.members.length > 0) {
                                const groupTotal = pricePerUnit * qty;
                                const perPerson = groupTotal / group.members.length;
                                group.members.forEach(person => {
                                    if (totals[person] !== undefined) {
                                        totals[person] += perPerson;
                                    }
                                });
                            }
                        });
                    }
                });

                return totals;
            };

            const getTotalPercentage = () => {
                return Object.values(customSplit).reduce((sum, val) => sum + val, 0);
            };

            const getTotalQuantity = () => {
                return Object.values(quantitySplit).reduce((sum, val) => sum + val, 0);
            };

            // Detect if there's an active bill split
            const hasActiveSplit = () => {
                return items.length > 0 && initialConfig !== null;
            };

            // Analyze config changes to determine if they're destructive
            const analyzeConfigChanges = (oldConfig, newConfig) => {
                const changes = [];
                let isDestructive = false;

                // Check for added people
                const addedPeople = newConfig.people.filter(p => !oldConfig.people.includes(p));
                addedPeople.forEach(person => {
                    const group = newConfig.groups.find(g => g.members.includes(person));
                    changes.push(`Added ${person} to ${group ? group.name : 'no group'}`);
                    isDestructive = true;
                });

                // Check for deleted people
                const deletedPeople = oldConfig.people.filter(p => !newConfig.people.includes(p));
                deletedPeople.forEach(person => {
                    const group = oldConfig.groups.find(g => g.members.includes(person));
                    changes.push(`Removed ${person} from ${group ? group.name : 'household'}`);
                    isDestructive = true;
                });

                // Check for people who moved groups
                oldConfig.people.forEach(person => {
                    if (newConfig.people.includes(person)) {
                        const oldGroup = oldConfig.groups.find(g => g.members.includes(person));
                        const newGroup = newConfig.groups.find(g => g.members.includes(person));
                        if (oldGroup && newGroup && oldGroup.name !== newGroup.name) {
                            changes.push(`Moved ${person} from ${oldGroup.name} to ${newGroup.name}`);
                            isDestructive = true;
                        }
                    }
                });

                // Check for added groups
                const addedGroups = newConfig.groups.filter(g => !oldConfig.groups.some(og => og.name === g.name));
                addedGroups.forEach(group => {
                    changes.push(`Added group: ${group.name}`);
                    isDestructive = true;
                });

                // Check for deleted groups
                const deletedGroups = oldConfig.groups.filter(g => !newConfig.groups.some(ng => ng.name === g.name));
                deletedGroups.forEach(group => {
                    changes.push(`Removed group: ${group.name}`);
                    isDestructive = true;
                });

                // Check for renamed people (non-destructive)
                // This is tricky - we can't easily detect renames vs add/delete
                // So we'll just catch group renames

                // Check for renamed groups (non-destructive)
                oldConfig.groups.forEach((oldGroup, idx) => {
                    if (idx < newConfig.groups.length) {
                        const newGroup = newConfig.groups.find(ng =>
                            ng.members.length === oldGroup.members.length &&
                            ng.members.every(m => oldGroup.members.includes(m))
                        );
                        if (newGroup && newGroup.name !== oldGroup.name) {
                            changes.push(`Renamed group "${oldGroup.name}" to "${newGroup.name}"`);
                            // Group renames are non-destructive
                        }
                    }
                });

                return { changes, isDestructive };
            };

            // Reset the bill split (restart assignment process with same items)
            const resetBillSplit = () => {
                // Keep items array intact - only reset the assignment state
                setCurrentItemIndex(0);
                setAssignments({});
                setShowSummary(false);
                setShowCustomSplit(false);
                // Note: we keep items and initialConfig so receipt stays in memory
            };

            // Review Screen component
            const ReviewScreen = () => {
                const [editingItem, setEditingItem] = useState(null);

                const getConfidenceBadge = (index) => {
                    const prediction = predictions[index];
                    if (!prediction) {
                        return { text: 'Not predicted', className: 'none', icon: '○' };
                    }

                    if (prediction.confidence === 'high') {
                        return { text: reviewAssignments[index] || 'Not assigned', className: 'high', icon: '✓' };
                    } else if (prediction.confidence === 'medium') {
                        return { text: reviewAssignments[index] || 'Not assigned', className: 'medium', icon: '~' };
                    } else {
                        return { text: 'Not predicted', className: 'none', icon: '○' };
                    }
                };

                const changeAssignment = (index, newGroup) => {
                    const newReviewAssignments = { ...reviewAssignments };
                    if (newGroup === '__none__') {
                        delete newReviewAssignments[index];
                    } else {
                        newReviewAssignments[index] = newGroup;
                    }
                    setReviewAssignments(newReviewAssignments);
                    setEditingItem(null);
                };

                const startSplitting = () => {
                    // Apply review assignments to actual assignments
                    setAssignments({ ...reviewAssignments });
                    setShowReviewScreen(false);
                };

                const skipPredictions = () => {
                    setReviewAssignments({});
                    setShowReviewScreen(false);
                };

                const autoAssignedCount = Object.keys(reviewAssignments).length;
                const needsReviewCount = items.length - autoAssignedCount;

                return (
                    <div className="card" style={{ position: 'relative' }}>
                        <button
                            className="settings-button"
                            onClick={() => setShowSettings(true)}
                        >
                            ⚙️
                        </button>

                        <h1 className="title">Review Predicted Assignments</h1>
                        <p className="subtitle">We've predicted assignments based on your history. Review and make changes if needed.</p>

                        <div className="review-summary">
                            <div className="review-summary-stat">
                                {autoAssignedCount} items auto-assigned, {needsReviewCount} items need review
                            </div>
                            <div className="review-summary-text">
                                Review the predictions below and make any necessary changes before starting
                            </div>
                        </div>

                        <div style={{ overflowX: 'auto' }}>
                            <table className="review-table">
                                <thead>
                                    <tr>
                                        <th>Item</th>
                                        <th style={{ width: '80px' }}>Qty</th>
                                        <th style={{ width: '100px' }}>Price</th>
                                        <th style={{ width: '180px' }}>Predicted Assignment</th>
                                        <th style={{ width: '100px' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {items.map((item, index) => {
                                        const badge = getConfidenceBadge(index);
                                        const prediction = predictions[index];

                                        return (
                                            <tr key={index}>
                                                <td style={{ fontWeight: '500', color: '#1f2937' }}>{item.name}</td>
                                                <td>{item.quantity}</td>
                                                <td>£{item.price.toFixed(2)}</td>
                                                <td>
                                                    {editingItem === index ? (
                                                        <select
                                                            className="group-select"
                                                            value={reviewAssignments[index] || '__none__'}
                                                            onChange={(e) => changeAssignment(index, e.target.value)}
                                                            autoFocus
                                                            style={{ fontSize: '13px', padding: '6px' }}
                                                        >
                                                            <option value="__none__">-- None --</option>
                                                            {config.groups.map(group => (
                                                                <option key={group.name} value={group.name}>{group.name}</option>
                                                            ))}
                                                            <option value="Shared">Shared</option>
                                                        </select>
                                                    ) : (
                                                        <div className={`prediction-badge ${badge.className}`}>
                                                            <span>{badge.icon}</span>
                                                            <span>{badge.text}</span>
                                                            {prediction && prediction.count > 0 && (
                                                                <span style={{ fontSize: '11px', opacity: 0.8 }}>
                                                                    ({prediction.count}x)
                                                                </span>
                                                            )}
                                                        </div>
                                                    )}
                                                </td>
                                                <td>
                                                    <button
                                                        className="change-button"
                                                        onClick={() => setEditingItem(editingItem === index ? null : index)}
                                                    >
                                                        {editingItem === index ? 'Done' : 'Change'}
                                                    </button>
                                                </td>
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div>

                        <div className="button-group" style={{ marginTop: '24px' }}>
                            <button className="button button-back" onClick={skipPredictions}>
                                Skip Predictions
                            </button>
                            <button className="button button-primary" onClick={startSplitting}>
                                Start Splitting
                            </button>
                        </div>
                    </div>
                );
            };

            // Settings modal component
            const SettingsModal = () => {
                const [editingPeople, setEditingPeople] = useState([...config.people]);
                const [editingGroups, setEditingGroups] = useState(config.groups.map(g => ({ ...g, members: [...g.members] })));
                const [showPersonModal, setShowPersonModal] = useState(false);
                const [showGroupModal, setShowGroupModal] = useState(false);
                const [newPersonName, setNewPersonName] = useState('');
                const [newGroupName, setNewGroupName] = useState('');
                const [editingGroupIndex, setEditingGroupIndex] = useState(null);

                const [selectedGroup, setSelectedGroup] = useState('');
                const [isCreatingNewGroup, setIsCreatingNewGroup] = useState(false);
                const [newGroupForPerson, setNewGroupForPerson] = useState('');
                const [validationError, setValidationError] = useState('');

                const addPerson = () => {
                    setNewPersonName('');
                    setSelectedGroup('');
                    setIsCreatingNewGroup(false);
                    setNewGroupForPerson('');
                    setValidationError('');
                    setShowPersonModal(true);
                };

                const savePerson = () => {
                    // Validation
                    if (!newPersonName.trim()) {
                        setValidationError('Name is required');
                        return;
                    }

                    let targetGroupName = '';

                    if (isCreatingNewGroup) {
                        if (!newGroupForPerson.trim()) {
                            setValidationError('Group name is required');
                            return;
                        }
                        targetGroupName = newGroupForPerson.trim();

                        // Check if group already exists
                        if (editingGroups.some(g => g.name === targetGroupName)) {
                            setValidationError('Group already exists');
                            return;
                        }

                        // Create the new group with the new person as member
                        const newGroup = { name: targetGroupName, members: [newPersonName.trim()] };
                        setEditingGroups([...editingGroups, newGroup]);
                    } else {
                        if (!selectedGroup) {
                            setValidationError('Please select a group or create a new one');
                            return;
                        }
                        targetGroupName = selectedGroup;

                        // Add person to selected group
                        const newGroups = editingGroups.map(group => {
                            if (group.name === targetGroupName) {
                                return { ...group, members: [...group.members, newPersonName.trim()] };
                            }
                            return group;
                        });
                        setEditingGroups(newGroups);
                    }

                    setEditingPeople([...editingPeople, newPersonName.trim()]);
                    setShowPersonModal(false);
                };

                const deletePerson = (index) => {
                    const personName = editingPeople[index];
                    const personGroup = getPersonGroup(personName);

                    if (personGroup) {
                        const group = editingGroups.find(g => g.name === personGroup);
                        if (group && group.members.length === 1) {
                            if (!confirm(`Deleting ${personName} will leave the "${personGroup}" group empty. The group will be deleted. Continue?`)) {
                                return;
                            }
                        } else {
                            if (!confirm(`Delete ${personName}? They will be removed from "${personGroup}".`)) {
                                return;
                            }
                        }
                    } else {
                        if (!confirm(`Delete ${personName}?`)) {
                            return;
                        }
                    }

                    const newPeople = editingPeople.filter((_, i) => i !== index);
                    let newGroups = editingGroups.map(group => ({
                        ...group,
                        members: group.members.filter(m => m !== personName)
                    }));

                    // Remove empty groups
                    newGroups = newGroups.filter(group => group.members.length > 0);

                    setEditingPeople(newPeople);
                    setEditingGroups(newGroups);
                };

                // Get which group a person belongs to
                const getPersonGroup = (person) => {
                    for (const group of editingGroups) {
                        if (group.members.includes(person)) {
                            return group.name;
                        }
                    }
                    return null;
                };

                // Change person's group assignment
                const changePersonGroup = (person, newGroupName) => {
                    // Remove person from all groups
                    const newGroups = editingGroups.map(group => ({
                        ...group,
                        members: group.members.filter(m => m !== person)
                    }));

                    // Add person to the new group
                    const groupIndex = newGroups.findIndex(g => g.name === newGroupName);
                    if (groupIndex !== -1) {
                        newGroups[groupIndex].members.push(person);
                    }

                    setEditingGroups(newGroups);
                };

                const addGroup = () => {
                    setNewGroupName('');
                    setShowGroupModal(true);
                };

                const saveGroup = () => {
                    if (!newGroupName.trim()) return;
                    if (editingGroupIndex !== null) {
                        // Renaming existing group
                        const newGroups = [...editingGroups];
                        newGroups[editingGroupIndex].name = newGroupName.trim();
                        setEditingGroups(newGroups);
                        setEditingGroupIndex(null);
                    } else {
                        // Adding new group
                        setEditingGroups([...editingGroups, { name: newGroupName.trim(), members: [] }]);
                    }
                    setShowGroupModal(false);
                };

                const startEditGroupName = (index) => {
                    setNewGroupName(editingGroups[index].name);
                    setEditingGroupIndex(index);
                    setShowGroupModal(true);
                };

                const [showDeleteGroupModal, setShowDeleteGroupModal] = useState(false);
                const [groupToDelete, setGroupToDelete] = useState(null);
                const [reassignToGroup, setReassignToGroup] = useState('');
                const [createGroupForReassign, setCreateGroupForReassign] = useState(false);
                const [newGroupForReassign, setNewGroupForReassign] = useState('');

                const deleteGroup = (index) => {
                    const group = editingGroups[index];

                    if (group.members.length === 0) {
                        // No members, delete directly
                        if (confirm(`Delete the "${group.name}" group?`)) {
                            const newGroups = editingGroups.filter((_, i) => i !== index);
                            setEditingGroups(newGroups);
                        }
                    } else {
                        // Has members, show reassignment modal
                        setGroupToDelete(index);
                        setReassignToGroup('');
                        setCreateGroupForReassign(false);
                        setNewGroupForReassign('');
                        setShowDeleteGroupModal(true);
                    }
                };

                const confirmDeleteGroup = () => {
                    if (groupToDelete === null) return;

                    const group = editingGroups[groupToDelete];
                    let targetGroupName = '';

                    if (createGroupForReassign) {
                        if (!newGroupForReassign.trim()) {
                            alert('Please enter a group name');
                            return;
                        }
                        targetGroupName = newGroupForReassign.trim();

                        // Check if group already exists
                        if (editingGroups.some(g => g.name === targetGroupName)) {
                            alert('Group already exists');
                            return;
                        }
                    } else {
                        if (!reassignToGroup) {
                            alert('Please select a group or create a new one');
                            return;
                        }
                        targetGroupName = reassignToGroup;
                    }

                    // Reassign members
                    let newGroups = [...editingGroups];

                    if (createGroupForReassign) {
                        // Create new group with the members
                        newGroups.push({ name: targetGroupName, members: [...group.members] });
                    } else {
                        // Add members to existing group
                        newGroups = newGroups.map(g => {
                            if (g.name === targetGroupName) {
                                return { ...g, members: [...g.members, ...group.members] };
                            }
                            return g;
                        });
                    }

                    // Remove the deleted group
                    newGroups = newGroups.filter((_, i) => i !== groupToDelete);

                    setEditingGroups(newGroups);
                    setShowDeleteGroupModal(false);
                    setGroupToDelete(null);
                };

                const getMemberCount = (groupName) => {
                    const group = editingGroups.find(g => g.name === groupName);
                    return group ? group.members.length : 0;
                };

                const saveSettings = () => {
                    const newConfig = {
                        people: editingPeople,
                        groups: editingGroups
                    };

                    // Check if there's an active bill split
                    if (hasActiveSplit()) {
                        const { changes, isDestructive } = analyzeConfigChanges(initialConfig, newConfig);

                        if (isDestructive) {
                            // Show warning modal
                            setConfigChanges(changes);
                            setPendingConfig(newConfig);
                            setShowResetWarning(true);
                            return;
                        }
                    }

                    // No active split or non-destructive changes - apply immediately
                    setConfig(newConfig);
                    saveConfig(newConfig);
                    setShowSettings(false);
                };

                return (
                    <div className="card settings-container">
                        <h1 className="title">Settings</h1>
                        <p className="subtitle">Manage people and group assignments</p>

                        {hasActiveSplit() && (
                            <div className="active-split-notice">
                                <div className="active-split-notice-icon">⚠️</div>
                                <div className="active-split-notice-text">
                                    Active bill split in progress. Some changes will reset your progress.
                                </div>
                            </div>
                        )}

                        <div className="settings-section">
                            <div className="settings-section-title">People & Group Assignment</div>
                            <table className="settings-table">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Group</th>
                                        <th style={{ width: '100px' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {editingPeople.map((person, index) => (
                                        <tr key={index}>
                                            <td style={{ fontWeight: '600', color: '#1f2937' }}>{person}</td>
                                            <td>
                                                <select
                                                    className="group-select"
                                                    value={getPersonGroup(person) || ''}
                                                    onChange={(e) => changePersonGroup(person, e.target.value)}
                                                >
                                                    {editingGroups.map(group => (
                                                        <option key={group.name} value={group.name}>{group.name}</option>
                                                    ))}
                                                </select>
                                            </td>
                                            <td>
                                                <div className="item-actions">
                                                    <button className="icon-button delete" onClick={() => deletePerson(index)}>🗑️</button>
                                                </div>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                            <button className="add-button" onClick={addPerson}>+ Add Person</button>
                        </div>

                        <div className="settings-section">
                            <div className="settings-section-title">Manage Groups</div>
                            <div className="group-list">
                                {editingGroups.map((group, index) => (
                                    <div key={index} className="group-item">
                                        <div style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                                            <span className="group-name-display">{group.name}</span>
                                            <span className="group-member-count">({getMemberCount(group.name)} {getMemberCount(group.name) === 1 ? 'person' : 'people'})</span>
                                        </div>
                                        <div className="item-actions">
                                            <button className="icon-button" onClick={() => startEditGroupName(index)}>✏️</button>
                                            <button className="icon-button delete" onClick={() => deleteGroup(index)}>🗑️</button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                            <button className="add-button" onClick={addGroup}>+ Add Group</button>
                        </div>

                        <div className="settings-section">
                            <div className="settings-section-title">Smart Predictions</div>

                            <div className="settings-toggle">
                                <div>
                                    <div className="settings-toggle-label">Enable smart predictions</div>
                                    <div className="settings-toggle-description">Predict assignments based on your history</div>
                                </div>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={predictionSettings.enablePredictions}
                                        onChange={(e) => {
                                            const newSettings = { ...predictionSettings, enablePredictions: e.target.checked };
                                            setPredictionSettings(newSettings);
                                            savePredictionSettings(newSettings);
                                        }}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </div>

                            <div className="settings-toggle">
                                <div>
                                    <div className="settings-toggle-label">Show review screen</div>
                                    <div className="settings-toggle-description">Review predictions before item-by-item flow</div>
                                </div>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={predictionSettings.showReviewScreen}
                                        onChange={(e) => {
                                            const newSettings = { ...predictionSettings, showReviewScreen: e.target.checked };
                                            setPredictionSettings(newSettings);
                                            savePredictionSettings(newSettings);
                                        }}
                                        disabled={!predictionSettings.enablePredictions}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </div>

                            <div className="settings-toggle">
                                <div>
                                    <div className="settings-toggle-label">Auto-apply high confidence predictions</div>
                                    <div className="settings-toggle-description">Automatically assign items seen 3+ times</div>
                                </div>
                                <label className="toggle-switch">
                                    <input
                                        type="checkbox"
                                        checked={predictionSettings.autoApplyHighConfidence}
                                        onChange={(e) => {
                                            const newSettings = { ...predictionSettings, autoApplyHighConfidence: e.target.checked };
                                            setPredictionSettings(newSettings);
                                            savePredictionSettings(newSettings);
                                        }}
                                        disabled={!predictionSettings.enablePredictions}
                                    />
                                    <span className="toggle-slider"></span>
                                </label>
                            </div>

                            <button
                                className="clear-history-button"
                                onClick={() => {
                                    if (confirm('Are you sure you want to clear all prediction history? This cannot be undone.')) {
                                        clearPredictionHistory();
                                        setPredictionHistory({});
                                        alert('Prediction history cleared successfully!');
                                    }
                                }}
                            >
                                Clear Prediction History
                            </button>
                        </div>

                        <div className="button-group" style={{ marginTop: '24px' }}>
                            <button className="button button-back" onClick={() => setShowSettings(false)}>Cancel</button>
                            <button className="button button-primary" onClick={saveSettings}>Save Changes</button>
                        </div>

                        {showPersonModal && (
                            <div className="modal-overlay" onClick={() => setShowPersonModal(false)}>
                                <div className="modal-content" onClick={(e) => e.stopPropagation()} style={{ maxWidth: '450px' }}>
                                    <h2 className="modal-title">Add Person</h2>

                                    {validationError && (
                                        <div className="error-message">
                                            {validationError}
                                        </div>
                                    )}

                                    <div className="form-group">
                                        <label className="form-label">Name *</label>
                                        <input
                                            className="form-input"
                                            type="text"
                                            value={newPersonName}
                                            onChange={(e) => {
                                                setNewPersonName(e.target.value);
                                                setValidationError('');
                                            }}
                                            placeholder="Enter name"
                                            autoFocus
                                            onKeyPress={(e) => {
                                                if (e.key === 'Enter' && !isCreatingNewGroup) savePerson();
                                            }}
                                        />
                                    </div>

                                    <div className="form-group">
                                        <label className="form-label">Group *</label>
                                        {!isCreatingNewGroup ? (
                                            <>
                                                <select
                                                    className="form-input"
                                                    value={selectedGroup}
                                                    onChange={(e) => {
                                                        if (e.target.value === '__create_new__') {
                                                            setIsCreatingNewGroup(true);
                                                            setSelectedGroup('');
                                                        } else {
                                                            setSelectedGroup(e.target.value);
                                                            setValidationError('');
                                                        }
                                                    }}
                                                    style={{ cursor: 'pointer' }}
                                                >
                                                    <option value="">Select a group...</option>
                                                    {editingGroups.map(group => (
                                                        <option key={group.name} value={group.name}>{group.name}</option>
                                                    ))}
                                                    <option value="__create_new__">➕ Create New Group...</option>
                                                </select>
                                            </>
                                        ) : (
                                            <>
                                                <input
                                                    className="form-input"
                                                    type="text"
                                                    value={newGroupForPerson}
                                                    onChange={(e) => {
                                                        setNewGroupForPerson(e.target.value);
                                                        setValidationError('');
                                                    }}
                                                    placeholder="Enter new group name"
                                                    onKeyPress={(e) => {
                                                        if (e.key === 'Enter') savePerson();
                                                    }}
                                                />
                                                <div style={{ marginTop: '8px' }}>
                                                    <a
                                                        href="#"
                                                        onClick={(e) => {
                                                            e.preventDefault();
                                                            setIsCreatingNewGroup(false);
                                                            setNewGroupForPerson('');
                                                        }}
                                                        style={{ color: '#667eea', fontSize: '14px', textDecoration: 'none' }}
                                                    >
                                                        ← Use Existing Group
                                                    </a>
                                                </div>
                                            </>
                                        )}
                                    </div>

                                    <div className="modal-actions">
                                        <button className="button button-back" onClick={() => setShowPersonModal(false)}>Cancel</button>
                                        <button className="button button-primary" onClick={savePerson}>Add Person</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {showGroupModal && (
                            <div className="modal-overlay" onClick={() => setShowGroupModal(false)}>
                                <div className="modal-content" onClick={(e) => e.stopPropagation()} style={{ maxWidth: '400px' }}>
                                    <h2 className="modal-title">{editingGroupIndex !== null ? 'Rename Group' : 'Add Group'}</h2>
                                    <div className="form-group">
                                        <label className="form-label">Group Name</label>
                                        <input
                                            className="form-input"
                                            type="text"
                                            value={newGroupName}
                                            onChange={(e) => setNewGroupName(e.target.value)}
                                            placeholder="Enter group name"
                                            autoFocus
                                            onKeyPress={(e) => {
                                                if (e.key === 'Enter') saveGroup();
                                            }}
                                        />
                                    </div>
                                    <div className="modal-actions">
                                        <button className="button button-back" onClick={() => setShowGroupModal(false)}>Cancel</button>
                                        <button className="button button-primary" onClick={saveGroup}>
                                            {editingGroupIndex !== null ? 'Rename' : 'Add'}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {showDeleteGroupModal && groupToDelete !== null && (
                            <div className="modal-overlay" onClick={() => setShowDeleteGroupModal(false)}>
                                <div className="modal-content" onClick={(e) => e.stopPropagation()} style={{ maxWidth: '500px' }}>
                                    <h2 className="modal-title">Delete Group</h2>

                                    <div className="warning-box">
                                        <p className="warning-title">
                                            The "{editingGroups[groupToDelete].name}" group has {editingGroups[groupToDelete].members.length} {editingGroups[groupToDelete].members.length === 1 ? 'person' : 'people'}.
                                        </p>
                                        <p className="warning-text">
                                            What should we do with {editingGroups[groupToDelete].members.length === 1 ? 'them' : 'them'}?
                                        </p>
                                    </div>

                                    <div className="form-group">
                                        <label className="form-label">Move people to:</label>
                                        {!createGroupForReassign ? (
                                            <>
                                                <select
                                                    className="form-input"
                                                    value={reassignToGroup}
                                                    onChange={(e) => {
                                                        if (e.target.value === '__create_new__') {
                                                            setCreateGroupForReassign(true);
                                                            setReassignToGroup('');
                                                        } else {
                                                            setReassignToGroup(e.target.value);
                                                        }
                                                    }}
                                                    style={{ cursor: 'pointer' }}
                                                >
                                                    <option value="">Select a group...</option>
                                                    {editingGroups.filter((_, i) => i !== groupToDelete).map(group => (
                                                        <option key={group.name} value={group.name}>{group.name}</option>
                                                    ))}
                                                    <option value="__create_new__">➕ Create New Group...</option>
                                                </select>
                                            </>
                                        ) : (
                                            <>
                                                <input
                                                    className="form-input"
                                                    type="text"
                                                    value={newGroupForReassign}
                                                    onChange={(e) => setNewGroupForReassign(e.target.value)}
                                                    placeholder="Enter new group name"
                                                    autoFocus
                                                />
                                                <div style={{ marginTop: '8px' }}>
                                                    <a
                                                        href="#"
                                                        onClick={(e) => {
                                                            e.preventDefault();
                                                            setCreateGroupForReassign(false);
                                                            setNewGroupForReassign('');
                                                        }}
                                                        style={{ color: '#667eea', fontSize: '14px', textDecoration: 'none' }}
                                                    >
                                                        ← Use Existing Group
                                                    </a>
                                                </div>
                                            </>
                                        )}
                                    </div>

                                    <div className="modal-actions">
                                        <button className="button button-back" onClick={() => setShowDeleteGroupModal(false)}>Cancel</button>
                                        <button className="button button-primary" onClick={confirmDeleteGroup}>
                                            Delete Group
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            const currentItem = items[currentItemIndex];
            const progress = items.length > 0 ? (currentItemIndex / items.length) * 100 : 0;
            const totalPercentage = getTotalPercentage();
            const currentQty = currentItem ? (parseFloat(currentItem.quantity) || 1) : 1;
            const totalQty = getTotalQuantity();

            // Reset Warning Modal
            const ResetWarningModal = () => (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ maxWidth: '500px' }}>
                        <h2 className="modal-title">Reset Bill Split?</h2>

                        <div className="warning-box">
                            <p className="warning-title">
                                Changing the household configuration will reset your current bill split progress.
                            </p>
                            <p className="warning-text">
                                Your item assignments will be reset, but you'll keep the same receipt.
                            </p>
                        </div>

                        <div className="form-group">
                            <label className="form-label" style={{ fontWeight: 'bold', marginBottom: '12px' }}>Changes made:</label>
                            <div style={{ background: '#f9fafb', padding: '16px', borderRadius: '8px', border: '1px solid #d1d5db' }}>
                                <ul style={{ margin: 0, paddingLeft: '20px' }}>
                                    {configChanges.map((change, idx) => (
                                        <li key={idx} style={{ color: '#4b5563', marginBottom: '6px' }}>{change}</li>
                                    ))}
                                </ul>
                            </div>
                        </div>

                        <p style={{ color: '#6b7280', fontSize: '14px', marginTop: '16px' }}>
                            Continue with these changes?
                        </p>

                        <div className="modal-actions">
                            <button
                                className="button button-back"
                                onClick={() => {
                                    setShowResetWarning(false);
                                    setPendingConfig(null);
                                    setConfigChanges([]);
                                }}
                            >
                                Cancel
                            </button>
                            <button
                                className="button button-primary"
                                style={{ background: '#ef4444' }}
                                onClick={() => {
                                    // Apply the pending config
                                    setConfig(pendingConfig);
                                    saveConfig(pendingConfig);
                                    // Reset the bill split
                                    resetBillSplit();
                                    // Close modals
                                    setShowResetWarning(false);
                                    setShowSettings(false);
                                    setPendingConfig(null);
                                    setConfigChanges([]);
                                }}
                            >
                                Continue & Reset
                            </button>
                        </div>
                    </div>
                </div>
            );

            if (showSettings) {
                return (
                    <>
                        <SettingsModal />
                        {showResetWarning && <ResetWarningModal />}
                    </>
                );
            }

            if (loading) {
                return (
                    <div className="card">
                        <div className="loading">Loading PDF...</div>
                    </div>
                );
            }

            if (showReviewScreen) {
                return <ReviewScreen />;
            }

            if (showSummary) {
                const totals = calculateSummary();
                const totalBill = Object.values(totals).reduce((sum, val) => sum + val, 0);

                return (
                    <div className="card" style={{ position: 'relative' }}>
                        <button
                            className={`settings-button ${hasActiveSplit() ? 'active-split' : ''}`}
                            onClick={() => setShowSettings(true)}
                        >
                            ⚙️
                        </button>

                        <h1 className="title">Bill Summary</h1>
                        <p className="subtitle">Here's how much each person owes</p>

                        <div className="total-bill">
                            <div className="total-bill-label">Total Bill</div>
                            <div className="total-bill-amount">£{totalBill.toFixed(2)}</div>
                        </div>

                        <div className="summary-grid">
                            {config.people.map(person => (
                                <div key={person} className="person-card">
                                    <div className="person-name">{person}</div>
                                    <div className="person-amount">£{totals[person].toFixed(2)}</div>
                                </div>
                            ))}
                        </div>

                        {config.people.length > 1 && (
                            <div style={{ textAlign: 'center', marginTop: '24px', fontSize: '14px', color: '#6b7280' }}>
                                <strong>What others owe {config.people[0]}:</strong><br/>
                                {config.people.slice(1).map((person, idx) => (
                                    <span key={person}>
                                        {person}: £{totals[person].toFixed(2)}
                                        {idx < config.people.length - 2 ? ' | ' : ''}
                                    </span>
                                ))}
                            </div>
                        )}

                        <button className="button button-back" onClick={() => {
                            setShowSummary(false);
                            setCurrentItemIndex(items.length - 1);
                        }} style={{ marginTop: '24px', width: '100%' }}>
                            Start Over
                        </button>
                    </div>
                );
            }

            if (items.length > 0 && currentItem) {
                if (showCustomSplit) {
                    return (
                        <div className="card" style={{ position: 'relative' }}>
                            <button
                                className={`settings-button ${hasActiveSplit() ? 'active-split' : ''}`}
                                onClick={() => setShowSettings(true)}
                            >
                                ⚙️
                            </button>

                            <h2 className="title" style={{ fontSize: '24px' }}>Custom Split</h2>
                            <p className="subtitle">{currentItem.name}</p>

                            <div className="split-type-toggle">
                                <button
                                    className={`split-type-button ${splitType === 'percentage' ? 'active' : ''}`}
                                    onClick={() => setSplitType('percentage')}
                                >
                                    % Split
                                </button>
                                <button
                                    className={`split-type-button ${splitType === 'quantity' ? 'active' : ''}`}
                                    onClick={() => setSplitType('quantity')}
                                >
                                    Qty Split
                                </button>
                            </div>

                            {splitType === 'percentage' ? (
                                <div className="custom-split-panel">
                                    <div className="custom-split-title">
                                        Item Price: £{currentItem.price.toFixed(2)}
                                    </div>

                                    {config.people.map(person => (
                                        <div key={person} className="split-person-row">
                                            <div className="split-person-name">
                                                {person}
                                            </div>
                                            <div className="split-controls">
                                                <button
                                                    className="split-button"
                                                    onClick={() => updatePercentage(person, -5)}
                                                    disabled={(customSplit[person] || 0) <= 0}
                                                >
                                                    −
                                                </button>
                                                <input
                                                    type="number"
                                                    className="split-input"
                                                    value={(customSplit[person] || 0).toFixed(2)}
                                                    onChange={(e) => setPercentage(person, e.target.value)}
                                                    min="0"
                                                    max="100"
                                                    step="0.01"
                                                />
                                                <span style={{ fontSize: '16px', fontWeight: '600' }}>%</span>
                                                <button
                                                    className="split-button"
                                                    onClick={() => updatePercentage(person, 5)}
                                                    disabled={(customSplit[person] || 0) >= 100}
                                                >
                                                    +
                                                </button>
                                            </div>
                                            <div className="split-amount">
                                                £{((currentItem.price * (customSplit[person] || 0)) / 100).toFixed(2)}
                                            </div>
                                        </div>
                                    ))}

                                    <div style={{
                                        textAlign: 'center',
                                        marginTop: '16px',
                                        padding: '12px',
                                        background: totalPercentage === 100 ? '#d1fae5' : '#fee2e2',
                                        borderRadius: '8px',
                                        fontWeight: '600',
                                        color: totalPercentage === 100 ? '#065f46' : '#991b1b'
                                    }}>
                                        Total: {totalPercentage.toFixed(2)}%
                                        {totalPercentage !== 100 && ` (need 100%)`}
                                    </div>

                                    <div className="split-actions">
                                        <button className="button button-back" onClick={goBack}>
                                            Cancel
                                        </button>
                                        <button
                                            className="button button-secondary"
                                            onClick={resetToEqualSplit}
                                            style={{ flex: '0.8' }}
                                        >
                                            Reset
                                        </button>
                                        <button
                                            className="button button-primary"
                                            onClick={applyCustomSplit}
                                            disabled={totalPercentage !== 100}
                                        >
                                            Apply Split
                                        </button>
                                    </div>
                                </div>
                            ) : (
                                <div className="quantity-split-panel">
                                    <div className="custom-split-title" style={{ color: '#78350f' }}>
                                        Total Quantity: {currentQty} | Price: £{currentItem.price.toFixed(2)}
                                    </div>

                                    {config.groups.map(group => (
                                        <div key={group.name} className="quantity-split-row">
                                            <div className="quantity-split-label">{group.name}:</div>
                                            <input
                                                type="number"
                                                className="quantity-input"
                                                value={quantitySplit[group.name] || 0}
                                                onChange={(e) => updateQuantity(group.name, e.target.value)}
                                                min="0"
                                                max={currentQty}
                                            />
                                            <div style={{ fontSize: '14px', color: '#92400e' }}>
                                                £{((currentItem.price / currentQty) * (quantitySplit[group.name] || 0)).toFixed(2)}
                                            </div>
                                        </div>
                                    ))}

                                    <div className="quantity-total" style={{
                                        background: totalQty === currentQty ? '#d1fae5' : '#fee2e2',
                                        padding: '8px',
                                        borderRadius: '6px',
                                        fontWeight: '600',
                                        color: totalQty === currentQty ? '#065f46' : '#991b1b'
                                    }}>
                                        Allocated: {totalQty} / {currentQty}
                                        {totalQty !== currentQty && ` (must equal ${currentQty})`}
                                    </div>

                                    <div className="split-actions">
                                        <button className="button button-back" onClick={goBack}>
                                            Cancel
                                        </button>
                                        <button
                                            className="button button-primary"
                                            onClick={applyCustomSplit}
                                            disabled={totalQty !== currentQty}
                                        >
                                            Apply Split
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                }

                // Check if this item has already been assigned
                const currentAssignment = assignments[currentItemIndex];

                const renderAssignmentIndicator = () => {
                    if (!currentAssignment) return null;

                    if (typeof currentAssignment === 'string') {
                        // Simple assignment
                        return (
                            <div className="assignment-indicator">
                                <div className="assignment-title">Previously assigned to: {currentAssignment}</div>
                            </div>
                        );
                    } else if (currentAssignment.type === 'custom') {
                        // Percentage-based custom split
                        return (
                            <div className="assignment-indicator">
                                <div className="assignment-title">Custom % Split:</div>
                                <div className="assignment-detail">
                                    {Object.entries(currentAssignment.splits).map(([person, percent]) => (
                                        percent > 0 && (
                                            <div key={person} className="assignment-detail-row">
                                                <span>{person}:</span>
                                                <span>{percent.toFixed(2)}% (£{((currentItem.price * percent) / 100).toFixed(2)})</span>
                                            </div>
                                        )
                                    ))}
                                </div>
                            </div>
                        );
                    } else if (currentAssignment.type === 'quantity') {
                        // Quantity-based split
                        const pricePerUnit = currentItem.price / currentAssignment.totalQty;
                        return (
                            <div className="assignment-indicator">
                                <div className="assignment-title">Quantity Split:</div>
                                <div className="assignment-detail">
                                    {Object.entries(currentAssignment.splits).map(([groupName, qty]) => (
                                        <div key={groupName} className="assignment-detail-row">
                                            <span>{groupName}:</span>
                                            <span>{qty} items (£{(pricePerUnit * qty).toFixed(2)})</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        );
                    }
                };

                return (
                    <div className="card" style={{ position: 'relative' }}>
                        <button
                            className={`settings-button ${hasActiveSplit() ? 'active-split' : ''}`}
                            onClick={() => setShowSettings(true)}
                        >
                            ⚙️
                        </button>

                        <div className="progress-bar">
                            <div className="progress-fill" style={{ width: `${progress}%` }}></div>
                        </div>
                        <div className="progress-text">Item {currentItemIndex + 1} of {items.length}</div>

                        <div style={{ fontSize: '14px', color: '#6b7280', marginBottom: '16px' }}>
                            {progress.toFixed(0)}% complete
                        </div>

                        <div className="item-card">
                            <div className="item-name">{currentItem.name}</div>
                            <div className="item-details">
                                <span><strong>Qty:</strong> {currentItem.quantity}</span>
                                <span><strong>Price:</strong> £{currentItem.price.toFixed(2)}</span>
                            </div>
                        </div>

                        {renderAssignmentIndicator()}

                        {predictionSettings.enablePredictions && predictions[currentItemIndex] && !currentAssignment && (
                            <div className="suggestion-hint">
                                <div className="suggestion-hint-text">
                                    Suggested: <strong>{predictions[currentItemIndex].group}</strong>
                                </div>
                                <div className="suggestion-hint-subtext">
                                    Based on {predictions[currentItemIndex].count} previous {predictions[currentItemIndex].count === 1 ? 'time' : 'times'}
                                    {predictions[currentItemIndex].confidence === 'high' && ' (high confidence)'}
                                    {predictions[currentItemIndex].confidence === 'medium' && ' (medium confidence)'}
                                </div>
                            </div>
                        )}

                        {(() => {
                            const buttonColors = ['button-primary', 'button-secondary', 'button-tertiary'];
                            const prediction = predictions[currentItemIndex];
                            const rows = [];

                            for (let i = 0; i < config.groups.length; i += 2) {
                                const groupsInRow = config.groups.slice(i, i + 2);
                                rows.push(
                                    <div key={`row-${i / 2}`} className="button-group" style={{ marginTop: i === 0 ? '0' : '16px' }}>
                                        {groupsInRow.map((group, idx) => {
                                            const groupIndex = i + idx;
                                            const colorClass = buttonColors[groupIndex % buttonColors.length];
                                            const isPredicted = prediction && prediction.group === group.name;
                                            return (
                                                <button
                                                    key={group.name}
                                                    className={`button ${colorClass}`}
                                                    onClick={() => assignItem(group.name)}
                                                    style={isPredicted ? {
                                                        boxShadow: '0 0 0 3px rgba(251, 191, 36, 0.5)',
                                                        position: 'relative'
                                                    } : {}}
                                                >
                                                    {group.name} ({groupIndex + 1})
                                                    {isPredicted && <span style={{ marginLeft: '6px' }}>✨</span>}
                                                </button>
                                            );
                                        })}
                                    </div>
                                );
                            }

                            return rows;
                        })()}

                        <div className="button-group" style={{ marginTop: '16px' }}>
                            <button
                                className="button button-tertiary"
                                onClick={() => assignItem('Shared')}
                                style={prediction && prediction.group === 'Shared' ? {
                                    boxShadow: '0 0 0 3px rgba(251, 191, 36, 0.5)',
                                    position: 'relative'
                                } : {}}
                            >
                                Shared ({config.groups.length + 1})
                                {prediction && prediction.group === 'Shared' && <span style={{ marginLeft: '6px' }}>✨</span>}
                            </button>
                            <button className="button button-custom" onClick={openCustomSplit}>
                                Custom Split ({config.groups.length + 2})
                            </button>
                        </div>

                        <div style={{
                            marginTop: '12px',
                            padding: '8px 12px',
                            background: '#f3f4f6',
                            borderRadius: '8px',
                            fontSize: '13px',
                            color: '#6b7280',
                            textAlign: 'center'
                        }}>
                            Tip: Press 1-{config.groups.length + 2} for quick assignment | ← to go back | Esc to close
                        </div>

                        {currentItemIndex > 0 && (
                            <button className="button button-back" onClick={goBack} style={{ marginTop: '16px', width: '100%' }}>
                                ← Back
                            </button>
                        )}
                    </div>
                );
            }

            return (
                <div className="card" style={{ position: 'relative' }}>
                    <button className="settings-button" onClick={() => setShowSettings(true)}>
                        ⚙️
                    </button>

                    <h1 className="title">Sainsbury's Bill Splitter</h1>
                    <p className="subtitle">Upload your Sainsbury's receipt PDF to split the bill</p>

                    {error && <div className="error">{error}</div>}

                    <div
                        className={`upload-area ${dragOver ? 'drag-over' : ''}`}
                        onDrop={handleDrop}
                        onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
                        onDragLeave={() => setDragOver(false)}
                        onClick={() => document.getElementById('fileInput').click()}
                    >
                        <div className="upload-icon">📄</div>
                        <div className="upload-text">Drop your PDF here or click to browse</div>
                        <div className="upload-hint">Sainsbury's grocery receipt only</div>
                    </div>

                    <input
                        id="fileInput"
                        type="file"
                        accept="application/pdf"
                        onChange={handleFileSelect}
                        style={{ display: 'none' }}
                    />
                </div>
            );
        };

        ReactDOM.render(<BillSplitter />, document.getElementById('root'));
    </script>
</body>
</html>
